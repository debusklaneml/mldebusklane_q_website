[
  {
    "objectID": "posts/groupwalk/groupwalk.html",
    "href": "posts/groupwalk/groupwalk.html",
    "title": "group_walk",
    "section": "",
    "text": "library(tidyverse)\nlibrary(writexl)\n\nLet’s grab some data!!!\n\ndata(iris)\n\nLet’s take a look.\n\niris %>%\n  skimr::skim()\n\n\nData summary\n\n\nName\nPiped data\n\n\nNumber of rows\n150\n\n\nNumber of columns\n5\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nfactor\n1\n\n\nnumeric\n4\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: factor\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nordered\nn_unique\ntop_counts\n\n\n\n\nSpecies\n0\n1\nFALSE\n3\nset: 50, ver: 50, vir: 50\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nSepal.Length\n0\n1\n5.84\n0.83\n4.3\n5.1\n5.80\n6.4\n7.9\n▆▇▇▅▂\n\n\nSepal.Width\n0\n1\n3.06\n0.44\n2.0\n2.8\n3.00\n3.3\n4.4\n▁▆▇▂▁\n\n\nPetal.Length\n0\n1\n3.76\n1.77\n1.0\n1.6\n4.35\n5.1\n6.9\n▇▁▆▇▂\n\n\nPetal.Width\n0\n1\n1.20\n0.76\n0.1\n0.3\n1.30\n1.8\n2.5\n▇▁▇▅▃\n\n\n\n\n\nYou’ll notice that aside from the 4 numeric species attributes (Sepal & Petal length and width), there is an identification/classification variable (actually a factor variable) that denotes which Species each flower is.\nFor this demonstration, I’d like to create three seperate ‘.xlsx’ files simply based on this identification. What would be helpful, in the end, is to have each file named after this identification.\nThankfully, the {dplyr} package has made this super simple.\n\niris %>%\n  group_by(Species) %>% # Group by the variable for which you wish to iterate over to create individual files from.\n  group_walk(~ write_xlsx(.x, paste0(\"iris_\", .y$Species, \".xlsx\")), keep = TRUE)\n\n\ngroup_by\nTo walk through this a bit, you’ll notice a simple group_by function that serves to identify which column we wish to not only group our data by, but the one which we’d like to iterate over to make individual files from.\n\n\ngroup_walk (group_map)\nNext, the group_walk function, which is an extension of the group_map series (more info here) that mimics many purrr functions, except through a series of groups… not just a list, df columsn, or some type of nest.\nIdentical to the other walk functions that are used for their ‘side effects’ (think output, not what it returns… ), the group_walk function silently returns the .x argument. We’re interested in what it does, not the data it may produce. Afterall, I just want the output of the function. I plan to dive into this in a future map post in the future… it can be confusing. Nicely, the group_walk function also includes an option to keep the grouping variable through the keep = option that retains the variable in each .x.\nTo wrap this up, the paste0 function serves to meet the second argument requirement for write_xlsx. If you’re not familiar with paste0/paste, it simply combindes all arguments together. In this case, it is simply taking the string prefix “iris_,” each Species, and “.xlsx” and concatenates them.\n\n\n\n\nReusehttps://creativecommons.org/licenses/by/4.0/CitationBibTeX citation:@online{l.debusk-lane2020,\n  author = {M. L. DeBusk-Lane},\n  title = {Group\\_walk},\n  date = {2020-02-25},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nM. L. DeBusk-Lane. 2020. “Group_walk.” February 25, 2020."
  },
  {
    "objectID": "posts/soduku_R/sudoku_R.html",
    "href": "posts/soduku_R/sudoku_R.html",
    "title": "Sudoku Solver in R",
    "section": "",
    "text": "Using the basic sudoku puzzle from wikipedia HERE, we’ll start to build this out.\n\n\n\n\n\n\n\n\n\nUsing the same input methods as the python version (here)\nLets bring in the actual board…\n\nboard <- c(5,3,0,0,7,0,0,0,0,\n          6,0,0,1,9,5,0,0,0,\n          0,9,8,0,0,0,0,6,0,\n          8,0,0,0,6,0,0,0,3,\n          4,0,0,8,0,3,0,0,1,\n          7,0,0,0,2,0,0,0,6,\n          0,6,0,0,0,0,2,8,0,\n          0,0,0,4,1,9,0,0,5,\n          0,0,0,0,8,0,0,7,9)\n\nFirst, it’s important to push this into a matrix.\n\nboard <- matrix(board, nrow = 9, ncol = 9, byrow = TRUE) \n\nNext, lets develop the code to render each cell’s possible answers:\n\npossible <- function(board, i, j){\n  # Creates an all TRUE logical vector\n  possible <- rep(TRUE,9)\n  # Lists all known numbers from the row, column, and 3x3 cell\n  selected_num <- unique(c(board[i,], board[,j], board[3*((i-1) %/% 3) + 1:3, 3*((j-1) %/% 3) + 1:3]))\n  # Removes NAs\n  selected_num <- na.omit(selected_num)\n  # Changes the logical vector to FALSE for all values currently in use for the row, column, and 3x3 cell\n  possible[selected_num] <- FALSE\n  # Returns this logical vector for use in subsequent functions...\n  return(possible)\n}\n\nAs the comments imply, we are simply returning a logical vector list that describes which numbers are available or possible.\nNext, we’ll draft the function to iterate through all cells and determine a solution through recursion.\n\n# The 'board' argument here provides the matrix, length 81 (9x9), to iterate through. \n# The 'progress' argument here provides a starting value to recursively iterate through. \nsolve <- function(board, progress = 81) {\n  # Provision to make a matrix with 0s into NA for future processing\n  if  (0 %in% board) {\n    board[board == 0] <- NA\n  } else board\n  # Once all cells have been assessed within the 'possible_choices' function, it stops the recursion. \n  if (progress == 0) {\n    # Successfully filled in the board\n    return(board)\n  }\n  # Get the i,j coordinates\n  # A fancy way to iterate through the coordinate numbers one by one (right to left, bottom to top)\n  i <- ((progress - 1) %% 9) + 1 \n  j <- ((progress - 1) %/% 9) + 1 \n  # If a spot is open, identifies what numbers are available `choices`\n  if (is.na(board[i, j])) {\n    choices <- which(possible(board, i, j))\n  } else{\n    choices <- c(board[i, j])\n  }\n  # Try each possible choice, until all the requirements of the two functions are satisfied. \n  for (k in choices) {\n    board[i, j] <- k\n    # recursion\n    answer <- solve(board, progress - 1)\n    # If all possible positions have been completed, simply return the answer. \n    if (!is.null(answer)) {\n      return(answer)\n    }\n  }\n  return(NULL)\n}\n\nAlthough there is a lot going on here, I’ve attempted to put in some fairly descriptive comments. I tried to follow the Python code thematic plan, while using some of R’s fantastic infix operators to skip a few steps here or there and a bit of recursion. You’ll also note that I also switch all zeros to NAs, to make things a bit easier to code using is.na.\n\nsolve(board)\n\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n [1,]    5    3    4    6    7    8    9    1    2\n [2,]    6    7    2    1    9    5    3    4    8\n [3,]    1    9    8    3    4    2    5    6    7\n [4,]    8    5    9    7    6    1    4    2    3\n [5,]    4    2    6    8    5    3    7    9    1\n [6,]    7    1    3    9    2    4    8    5    6\n [7,]    9    6    1    5    3    7    2    8    4\n [8,]    2    8    7    4    1    9    6    3    5\n [9,]    3    4    5    2    8    6    1    7    9\n\n\nArguably, I’m not a base R coder or programmer. Therefore, much of this post was generated from various websites, SOF, and other corners of the web–the R community is amazing. In a future post, I’ll work to re-write this in some type of tidyverse rendition… if that is a thing. I’ll at least try.\n\n\n\nReusehttps://creativecommons.org/licenses/by/4.0/CitationBibTeX citation:@online{l.debusk-lane2020,\n  author = {M. L. DeBusk-Lane},\n  title = {Sudoku {Solver} in {R}},\n  date = {2020-02-28},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nM. L. DeBusk-Lane. 2020. “Sudoku Solver in R.” February 28,\n2020."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "M. L. DeBusk-Lane, Ph.D.",
    "section": "",
    "text": "I am a data geek, aviator, father, husband, and one who easily gets lost in figuring out just about anything.\nMy personal research focuses on writing self-efficacy and feedback, emotional reactivity, working memory, and various other musings such as creativity and intelligence in the student population. I am also deeply interested in unique quantitative methods, mixtures models, measurement design, machine learning, and longitudinal growth.\nCurrently, most of my work has centered around computational methods of natural language. These include word vector models, topic generation from word embeddings, and automated pipelines to develop such. My current interests/learnings in this space focus on zero-shot classification, transformer models, language inference and lexical prediction.\nAll opinions my own."
  },
  {
    "objectID": "cv.html",
    "href": "cv.html",
    "title": "CV",
    "section": "",
    "text": "This page is tbd."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Code\n\n\nR\n\n\n\n\n\n\n\n\n\n\n\nFeb 28, 2020\n\n\nM. L. DeBusk-Lane\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n\n\nR\n\n\n\n\n\n\n\n\n\n\n\nFeb 25, 2020\n\n\nM. L. DeBusk-Lane\n\n\n\n\n\n\nNo matching items"
  }
]