{
  "hash": "ff220447f602e23b8d661dad661199c0",
  "result": {
    "markdown": "---\ntitle: Sudoku Solver in R\ndate: '2020-02-28'\n\ncategories: \n  - Code\n  - R\n\noutput: \n  html_document:\n    theme: journal\n    highlight: zenburn\n---\n\n\n\n\nComing off of the wild excursion of getting Python markdown through RStudio's knitr (which didnt really work out well... I just exported a Jupyter Lab markdown and arranged it through my Hugo build), this is a brief vantage of how we might write the sudoku puzzle solver in the R language. Here we go.\n\nUsing the basic sudoku puzzle from wikipedia [HERE](https://en.wikipedia.org/wiki/Sudoku), we'll start to build this out.\n\n\n::: {.cell layout-align=\"center\" hash='sudoku_R_cache/html/unnamed-chunk-1_8fbb88babe851e0e24f115acd29ca470'}\n::: {.cell-output-display}\n[![](https://raw.githubusercontent.com/debusklaneml/mldebusklane.com/master/content/post/Random_Code/sudoku.png){fig-align='center'}](https://en.wikipedia.org/wiki/Sudoku)\n:::\n:::\n\n\nUsing the same input methods as the python version ([here](https://www.mldebusklane.com/post/random_code/sudoku/))\n\nLets bring in the actual board...\n\n\n::: {.cell hash='sudoku_R_cache/html/unnamed-chunk-2_8405d79e27a8c8346a7e3deef12ca592'}\n\n```{.r .cell-code}\nboard <- c(5,3,0,0,7,0,0,0,0,\n          6,0,0,1,9,5,0,0,0,\n          0,9,8,0,0,0,0,6,0,\n          8,0,0,0,6,0,0,0,3,\n          4,0,0,8,0,3,0,0,1,\n          7,0,0,0,2,0,0,0,6,\n          0,6,0,0,0,0,2,8,0,\n          0,0,0,4,1,9,0,0,5,\n          0,0,0,0,8,0,0,7,9)\n```\n:::\n\n\nFirst, it's important to push this into a matrix.\n\n\n::: {.cell hash='sudoku_R_cache/html/unnamed-chunk-3_cb4cd39346cd6f614f806d969ed2bc63'}\n\n```{.r .cell-code}\nboard <- matrix(board, nrow = 9, ncol = 9, byrow = TRUE) \n```\n:::\n\n\nNext, lets develop the code to render each cell's possible answers:\n\n\n::: {.cell hash='sudoku_R_cache/html/unnamed-chunk-4_b36fc2c19e549b5bce036fc4ce1d4669'}\n\n```{.r .cell-code}\npossible <- function(board, i, j){\n  # Creates an all TRUE logical vector\n  possible <- rep(TRUE,9)\n  # Lists all known numbers from the row, column, and 3x3 cell\n  selected_num <- unique(c(board[i,], board[,j], board[3*((i-1) %/% 3) + 1:3, 3*((j-1) %/% 3) + 1:3]))\n  # Removes NAs\n  selected_num <- na.omit(selected_num)\n  # Changes the logical vector to FALSE for all values currently in use for the row, column, and 3x3 cell\n  possible[selected_num] <- FALSE\n  # Returns this logical vector for use in subsequent functions...\n  return(possible)\n}\n```\n:::\n\n\nAs the comments imply, we are simply returning a logical vector list that describes which numbers are available or `possible`.\n\nNext, we'll draft the function to iterate through all cells and determine a solution through recursion.\n\n\n::: {.cell hash='sudoku_R_cache/html/unnamed-chunk-5_0abaabdeb992b6cac004c60aa0625e71'}\n\n```{.r .cell-code}\n# The 'board' argument here provides the matrix, length 81 (9x9), to iterate through. \n# The 'progress' argument here provides a starting value to recursively iterate through. \nsolve <- function(board, progress = 81) {\n  # Provision to make a matrix with 0s into NA for future processing\n  if  (0 %in% board) {\n    board[board == 0] <- NA\n  } else board\n  # Once all cells have been assessed within the 'possible_choices' function, it stops the recursion. \n  if (progress == 0) {\n    # Successfully filled in the board\n    return(board)\n  }\n  # Get the i,j coordinates\n  # A fancy way to iterate through the coordinate numbers one by one (right to left, bottom to top)\n  i <- ((progress - 1) %% 9) + 1 \n  j <- ((progress - 1) %/% 9) + 1 \n  # If a spot is open, identifies what numbers are available `choices`\n  if (is.na(board[i, j])) {\n    choices <- which(possible(board, i, j))\n  } else{\n    choices <- c(board[i, j])\n  }\n  # Try each possible choice, until all the requirements of the two functions are satisfied. \n  for (k in choices) {\n    board[i, j] <- k\n    # recursion\n    answer <- solve(board, progress - 1)\n    # If all possible positions have been completed, simply return the answer. \n    if (!is.null(answer)) {\n      return(answer)\n    }\n  }\n  return(NULL)\n}\n```\n:::\n\n\nAlthough there is a lot going on here, I've attempted to put in some fairly descriptive comments. I tried to follow the Python code thematic plan, while using some of R's fantastic infix operators to skip a few steps here or there and a bit of recursion. You'll also note that I also switch all zeros to NAs, to make things a bit easier to code using `is.na`.\n\n\n::: {.cell hash='sudoku_R_cache/html/unnamed-chunk-6_f12457b217dc41660b19c4ebeff92417'}\n\n```{.r .cell-code}\nsolve(board)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n [1,]    5    3    4    6    7    8    9    1    2\n [2,]    6    7    2    1    9    5    3    4    8\n [3,]    1    9    8    3    4    2    5    6    7\n [4,]    8    5    9    7    6    1    4    2    3\n [5,]    4    2    6    8    5    3    7    9    1\n [6,]    7    1    3    9    2    4    8    5    6\n [7,]    9    6    1    5    3    7    2    8    4\n [8,]    2    8    7    4    1    9    6    3    5\n [9,]    3    4    5    2    8    6    1    7    9\n```\n:::\n:::\n\n\nArguably, I'm not a base R coder or programmer. Therefore, much of this post was generated from various websites, SOF, and other corners of the web--the R community is amazing. In a future post, I'll work to re-write this in some type of tidyverse rendition... if that is a thing. I'll at least try.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}